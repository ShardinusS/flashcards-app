================================================================================
R√âSUM√â COMPLET DE L'APPLICATION FLASHCARDS
================================================================================

Ce fichier contient tout le code source de l'application FlashCards - AnkiApp Style
Une application PWA de flashcards avec r√©p√©tition espac√©e (algorithme SM-2)

Date de cr√©ation: 2024
Derni√®re mise √† jour: Version FINALE - S√©lection limit√©e de cartes par session + Algorithme de difficult√©
Structure: Application web vanilla (HTML, CSS, JavaScript)

================================================================================
FICHIER 1: index.html
================================================================================

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="FlashCards">
    <meta name="theme-color" content="#2196F3">
    <title>FlashCards - AnkiApp Style</title>
    <link rel="manifest" href="manifest.json">
    <link rel="stylesheet" href="style.css">
    <link rel="apple-touch-icon" href="icon-192.png">
</head>
<body>
    <!-- √âcran principal - Liste des decks -->
    <div id="decks-view" class="view active">
        <header>
            <h1>Mes Decks</h1>
            <button id="view-toggle" class="icon-btn" aria-label="Changer vue">
                <span id="view-icon">‚ò∞</span>
            </button>
        </header>
        
        <div id="decks-container" class="decks-grid">
            <!-- Les decks seront ajout√©s dynamiquement ici -->
        </div>
        
        <div class="fab-container">
            <button id="add-deck-btn" class="fab" aria-label="Ajouter un deck">
                <span>+</span>
            </button>
        </div>
    </div>

    <!-- √âcran d√©tail d'un deck -->
    <div id="deck-detail-view" class="view">
        <header>
            <button id="back-btn" class="icon-btn" aria-label="Retour">
                ‚Üê
            </button>
            <h1 id="deck-title">Deck</h1>
            <div class="header-actions">
                <button id="review-deck-btn" class="icon-btn" aria-label="R√©viser" title="R√©viser">
                    üîÑ
                </button>
                <button id="review-settings-btn" class="icon-btn" aria-label="Param√®tres de r√©vision" title="Param√®tres">
                    ‚öô
                </button>
                <button id="import-deck-btn" class="icon-btn" aria-label="Importer">
                    ‚¨á
                </button>
                <button id="export-deck-btn" class="icon-btn" aria-label="Exporter">
                    ‚¨Ü
                </button>
                <button id="edit-deck-btn" class="icon-btn" aria-label="Modifier">
                    ‚úé
                </button>
            </div>
        </header>
        
        <div id="cards-container" class="cards-list">
            <!-- Les cartes seront ajout√©es dynamiquement ici -->
        </div>
        
        <div class="fab-container">
            <button id="add-card-btn" class="fab" aria-label="Ajouter une carte">
                <span>+</span>
            </button>
        </div>
    </div>

    <!-- √âcran r√©vision -->
    <div id="review-view" class="view">
        <header>
            <button id="review-back-btn" class="icon-btn" aria-label="Retour">
                ‚Üê
            </button>
            <h1>R√©vision</h1>
            <div id="review-progress">0 / 0</div>
        </header>
        
        <div id="review-card" class="review-card">
            <div id="card-front" class="card-side">
                <p id="front-text"></p>
            </div>
            <div id="card-back" class="card-side hidden">
                <p id="back-text"></p>
            </div>
            <div id="reveal-hint" class="reveal-hint">Tapez pour r√©v√©ler</div>
        </div>
        
        <div id="review-buttons" class="review-buttons hidden">
            <button id="again-btn" class="review-btn again">Encore</button>
            <button id="good-btn" class="review-btn good">Bien</button>
            <button id="easy-btn" class="review-btn easy">Facile</button>
        </div>
    </div>

    <!-- Modals -->
    <div id="modal-overlay" class="modal-overlay hidden">
        <div class="modal">
            <div class="modal-header">
                <h2 id="modal-title">Titre</h2>
                <button class="modal-close" aria-label="Fermer">√ó</button>
            </div>
            <div class="modal-body">
                <div id="modal-content"></div>
            </div>
        </div>
    </div>

    <!-- Input file cach√© pour import -->
    <input type="file" id="import-file-input" accept=".json" style="display: none;">

    <script src="script.js"></script>
</body>
</html>

================================================================================
FICHIER 2: script.js
================================================================================

// ============================================
// GESTION DES DONN√âES
// ============================================

const Storage = {
    getDecks() {
        const data = localStorage.getItem('flashcards_decks');
        return data ? JSON.parse(data) : [];
    },
    
    saveDecks(decks) {
        localStorage.setItem('flashcards_decks', JSON.stringify(decks));
    },
    
    getDeck(id) {
        const decks = this.getDecks();
        return decks.find(d => d.id === id);
    },
    
    saveDeck(deck) {
        const decks = this.getDecks();
        const index = decks.findIndex(d => d.id === deck.id);
        if (index >= 0) {
            decks[index] = deck;
        } else {
            decks.push(deck);
        }
        this.saveDecks(decks);
    },
    
    deleteDeck(id) {
        const decks = this.getDecks();
        const filtered = decks.filter(d => d.id !== id);
        this.saveDecks(filtered);
    }
};

// ============================================
// ALGORITHME SM-2 SIMPLIFI√â
// ============================================

const SM2 = {
    calculateNextReview(card, quality) {
        const now = Date.now();
        
        if (!card.easeFactor) {
            card.easeFactor = 2.5;
        }
        if (!card.interval) {
            card.interval = 1;
        }
        if (!card.repetitions) {
            card.repetitions = 0;
        }
        if (!card.againCount) {
            card.againCount = 0;
        }
        
        if (quality === 0) {
            // Encore - incr√©menter le compteur et r√©initialiser
            card.againCount = (card.againCount || 0) + 1;
            card.interval = 1;
            card.repetitions = 0;
        } else {
            if (quality === 1) {
                card.easeFactor = Math.max(1.3, card.easeFactor - 0.15);
            } else {
                card.easeFactor = Math.max(1.3, card.easeFactor + 0.15);
            }
            
            card.repetitions += 1;
            
            if (card.repetitions === 1) {
                card.interval = 1;
            } else if (card.repetitions === 2) {
                card.interval = 6;
            } else {
                card.interval = Math.round(card.interval * card.easeFactor);
            }
        }
        
        const daysToAdd = card.interval;
        card.nextReview = now + (daysToAdd * 24 * 60 * 60 * 1000);
        card.lastReview = now;
        
        return card;
    },
    
    getCardsToReview(deck, limit = null) {
        // Retourner les cartes tri√©es par priorit√©, limit√©es au nombre demand√©
        // Priorit√© : cartes avec le plus de clics "Encore" en premier
        // Puis les cartes √† r√©viser (nextReview <= now)
        // Puis les autres cartes
        const now = Date.now();
        
        // Calculer un score de difficult√© pour chaque carte
        // Plus le score est √©lev√©, plus la carte est difficile et doit √™tre r√©vis√©e
        const cardsWithScore = deck.cards.map(card => {
            const againCount = card.againCount || 0;
            const isDue = !card.nextReview || card.nextReview <= now;
            const daysSinceLastReview = card.lastReview 
                ? Math.floor((now - card.lastReview) / (24 * 60 * 60 * 1000))
                : 999;
            
            // Score de difficult√© : 
            // - againCount * 100 (poids tr√®s important pour les cartes difficiles)
            // - +50 si la carte est due
            // - -daysSinceLastReview (les cartes r√©vis√©es r√©cemment sont moins prioritaires)
            const difficultyScore = (againCount * 100) + (isDue ? 50 : 0) - daysSinceLastReview;
            
            return {
                card: card,
                score: difficultyScore,
                isDue: isDue,
                againCount: againCount
            };
        });
        
        // Trier par score de difficult√© (d√©croissant)
        cardsWithScore.sort((a, b) => {
            if (b.score !== a.score) {
                return b.score - a.score;
            }
            // En cas d'√©galit√©, privil√©gier les cartes √† r√©viser
            if (a.isDue !== b.isDue) {
                return a.isDue ? -1 : 1;
            }
            // Puis par nombre de clics "Encore"
            if (b.againCount !== a.againCount) {
                return b.againCount - a.againCount;
            }
            // Enfin, par date de prochaine r√©vision (croissante)
            const aDate = a.card.nextReview || 0;
            const bDate = b.card.nextReview || 0;
            return aDate - bDate;
        });
        
        // Limiter le nombre de cartes si demand√©
        const result = cardsWithScore.map(item => item.card);
        return limit ? result.slice(0, limit) : result;
    }
};

// ============================================
// GESTION DE L'INTERFACE
// ============================================

const App = {
    currentDeckId: null,
    currentView: 'decks',
    isGridView: true,
    reviewCards: [],
    currentReviewIndex: 0,
    isRevealed: false,
    cardsPerSession: 10, // Nombre de cartes par session de r√©vision
    
    init() {
        // Charger la configuration du nombre de cartes par session
        const savedCardsPerSession = localStorage.getItem('flashcards_cardsPerSession');
        if (savedCardsPerSession) {
            this.cardsPerSession = parseInt(savedCardsPerSession) || 10;
        }
        
        this.setupEventListeners();
        this.renderDecks();
        this.registerServiceWorker();
    },
    
    setupEventListeners() {
        // Navigation
        document.getElementById('add-deck-btn').addEventListener('click', () => this.showAddDeckModal());
        document.getElementById('view-toggle').addEventListener('click', () => this.toggleView());
        document.getElementById('back-btn').addEventListener('click', () => this.showDecksView());
        document.getElementById('review-back-btn').addEventListener('click', () => this.showDeckDetailView());
        
        // Deck actions
        document.getElementById('review-deck-btn').addEventListener('click', () => this.startReview(this.currentDeckId));
        document.getElementById('review-settings-btn').addEventListener('click', () => this.showReviewSettingsModal());
        document.getElementById('edit-deck-btn').addEventListener('click', () => this.showEditDeckModal());
        document.getElementById('export-deck-btn').addEventListener('click', () => this.exportDeck());
        document.getElementById('import-deck-btn').addEventListener('click', () => {
            document.getElementById('import-file-input').click();
        });
        document.getElementById('import-file-input').addEventListener('change', (e) => this.importDeck(e));
        
        // Card actions
        document.getElementById('add-card-btn').addEventListener('click', () => this.showAddCardModal());
        
        // Review
        document.getElementById('review-card').addEventListener('click', () => this.revealAnswer());
        document.getElementById('again-btn').addEventListener('click', () => this.rateCard(0));
        document.getElementById('good-btn').addEventListener('click', () => this.rateCard(1));
        document.getElementById('easy-btn').addEventListener('click', () => this.rateCard(2));
        
        // Modal
        document.querySelector('.modal-close').addEventListener('click', () => this.hideModal());
        document.getElementById('modal-overlay').addEventListener('click', (e) => {
            if (e.target.id === 'modal-overlay') {
                this.hideModal();
            }
        });
    },
    
    // ============================================
    // NAVIGATION
    // ============================================
    
    showView(viewName) {
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        document.getElementById(`${viewName}-view`).classList.add('active');
        this.currentView = viewName;
    },
    
    showDecksView() {
        this.showView('decks');
        this.currentDeckId = null;
        this.renderDecks();
    },
    
    showDeckDetailView() {
        if (!this.currentDeckId) return;
        this.showView('deck-detail');
        this.renderCards();
    },
    
    showReviewView() {
        if (!this.currentDeckId) return;
        const deck = Storage.getDeck(this.currentDeckId);
        if (!deck) return;
        
        // Limiter le nombre de cartes selon la configuration
        this.reviewCards = SM2.getCardsToReview(deck, this.cardsPerSession);
        if (this.reviewCards.length === 0) {
            alert('Aucune carte dans ce deck !');
            return;
        }
        
        this.currentReviewIndex = 0;
        this.isRevealed = false;
        this.showView('review');
        
        // Attendre que la vue soit compl√®tement affich√©e avant de rendre la carte
        setTimeout(() => {
            this.renderReviewCard();
        }, 10);
    },
    
    toggleView() {
        this.isGridView = !this.isGridView;
        const container = document.getElementById('decks-container');
        const icon = document.getElementById('view-icon');
        
        if (this.isGridView) {
            container.classList.remove('list-view');
            icon.textContent = '‚ò∞';
        } else {
            container.classList.add('list-view');
            icon.textContent = '‚ò∑';
        }
    },
    
    // ============================================
    // RENDU DES DECKS
    // ============================================
    
    renderDecks() {
        const decks = Storage.getDecks();
        const container = document.getElementById('decks-container');
        
        if (decks.length === 0) {
            container.innerHTML = `
                <div class="empty-state" style="grid-column: 1 / -1;">
                    <div class="empty-state-icon">üìö</div>
                    <div class="empty-state-text">Aucun deck. Cr√©ez-en un pour commencer !</div>
                </div>
            `;
            return;
        }
        
        container.innerHTML = decks.map(deck => {
            const now = Date.now();
            const cardsDue = deck.cards.filter(card => !card.nextReview || card.nextReview <= now).length;
            const totalCards = deck.cards.length;
            
            return `
                <div class="deck-card" data-deck-id="${deck.id}">
                    <div class="deck-actions">
                        <button class="deck-action-btn" onclick="App.deleteDeck('${deck.id}')" title="Supprimer">üóë</button>
                        <button class="deck-action-btn" onclick="App.startReview('${deck.id}')" title="R√©viser">üîÑ</button>
                    </div>
                    <h3>${this.escapeHtml(deck.name)}</h3>
                    <div class="deck-info">
                        <span>${totalCards} carte${totalCards > 1 ? 's' : ''}</span>
                        ${cardsDue > 0 ? `<span style="color: var(--primary-color); font-weight: 600;">${cardsDue} √† r√©viser</span>` : ''}
                    </div>
                </div>
            `;
        }).join('');
        
        container.querySelectorAll('.deck-card').forEach(card => {
            const deckId = card.dataset.deckId;
            card.addEventListener('click', (e) => {
                if (!e.target.closest('.deck-actions')) {
                    this.openDeck(deckId);
                }
            });
        });
    },
    
    openDeck(deckId) {
        this.currentDeckId = deckId;
        const deck = Storage.getDeck(deckId);
        if (deck) {
            document.getElementById('deck-title').textContent = deck.name;
            this.showDeckDetailView();
        }
    },
    
    startReview(deckId) {
        this.currentDeckId = deckId;
        this.showReviewView();
    },
    
    // ============================================
    // RENDU DES CARTES
    // ============================================
    
    renderCards() {
        if (!this.currentDeckId) return;
        
        const deck = Storage.getDeck(this.currentDeckId);
        if (!deck) return;
        
        const container = document.getElementById('cards-container');
        
        if (deck.cards.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">üÉè</div>
                    <div class="empty-state-text">Aucune carte. Ajoutez-en une pour commencer !</div>
                </div>
            `;
            return;
        }
        
        container.innerHTML = deck.cards.map((card, index) => {
            const nextReview = card.nextReview ? new Date(card.nextReview).toLocaleDateString('fr-FR') : 'Jamais';
            
            return `
                <div class="card-item">
                    <div class="card-item-header">
                        <strong>Carte ${index + 1}</strong>
                    </div>
                    <div class="card-item-content">
                        <strong>Question:</strong> ${this.escapeHtml(card.front)}<br>
                        <strong>R√©ponse:</strong> ${this.escapeHtml(card.back)}
                    </div>
                    <div class="card-item-content" style="font-size: 12px; color: var(--text-secondary);">
                        Prochaine r√©vision: ${nextReview}
                    </div>
                    <div class="card-item-actions">
                        <button class="card-action-btn" onclick="App.editCard(${index})">Modifier</button>
                        <button class="card-action-btn" onclick="App.deleteCard(${index})" style="color: var(--error);">Supprimer</button>
                    </div>
                </div>
            `;
        }).join('');
    },
    
    // ============================================
    // MODALS - IDs CORRIG√âS POUR √âVITER LES CONFLITS
    // ============================================
    
    showModal(title, content) {
        document.getElementById('modal-title').textContent = title;
        document.getElementById('modal-content').innerHTML = content;
        document.getElementById('modal-overlay').classList.remove('hidden');
    },
    
    hideModal() {
        document.getElementById('modal-overlay').classList.add('hidden');
    },
    
    showAddDeckModal() {
        const content = `
            <form id="add-deck-form">
                <div class="form-group">
                    <label for="deck-name">Nom du deck</label>
                    <input type="text" id="deck-name" required placeholder="Ex: Vocabulaire anglais">
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="App.hideModal()">Annuler</button>
                    <button type="submit" class="btn btn-primary">Cr√©er</button>
                </div>
            </form>
        `;
        
        this.showModal('Nouveau deck', content);
        
        setTimeout(() => {
            const form = document.getElementById('add-deck-form');
            if (form) {
                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const name = document.getElementById('deck-name').value.trim();
                    if (name) {
                        this.createDeck(name);
                        this.hideModal();
                    }
                });
            }
        }, 10);
    },
    
    showEditDeckModal() {
        if (!this.currentDeckId) return;
        const deck = Storage.getDeck(this.currentDeckId);
        if (!deck) return;
        
        const content = `
            <form id="edit-deck-form">
                <div class="form-group">
                    <label for="edit-deck-name">Nom du deck</label>
                    <input type="text" id="edit-deck-name" value="${this.escapeHtml(deck.name)}" required>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="App.hideModal()">Annuler</button>
                    <button type="submit" class="btn btn-primary">Enregistrer</button>
                </div>
            </form>
        `;
        
        this.showModal('Modifier le deck', content);
        
        setTimeout(() => {
            const form = document.getElementById('edit-deck-form');
            if (form) {
                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const name = document.getElementById('edit-deck-name').value.trim();
                    if (name) {
                        this.updateDeck(name);
                        this.hideModal();
                    }
                });
            }
        }, 10);
    },
    
    showReviewSettingsModal() {
        const content = `
            <form id="review-settings-form">
                <div class="form-group">
                    <label for="cards-per-session">Nombre de cartes par session</label>
                    <input type="number" id="cards-per-session" min="1" max="100" value="${this.cardsPerSession}" required>
                    <small style="color: var(--text-secondary); display: block; margin-top: 5px;">
                        Les cartes les plus difficiles seront privil√©gi√©es
                    </small>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="App.hideModal()">Annuler</button>
                    <button type="submit" class="btn btn-primary">Enregistrer</button>
                </div>
            </form>
        `;
        
        this.showModal('Param√®tres de r√©vision', content);
        
        setTimeout(() => {
            const form = document.getElementById('review-settings-form');
            if (form) {
                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const cardsPerSession = parseInt(document.getElementById('cards-per-session').value);
                    if (cardsPerSession > 0 && cardsPerSession <= 100) {
                        this.cardsPerSession = cardsPerSession;
                        // Sauvegarder dans localStorage
                        localStorage.setItem('flashcards_cardsPerSession', cardsPerSession.toString());
                        this.hideModal();
                        alert(`Configuration enregistr√©e : ${cardsPerSession} cartes par session`);
                    } else {
                        alert('Veuillez entrer un nombre entre 1 et 100');
                    }
                });
            }
        }, 10);
    },
    
    showAddCardModal() {
        if (!this.currentDeckId) {
            alert('Veuillez d\'abord ouvrir un deck');
            return;
        }
        
        // IDs MODIFI√âS: input-card-front et input-card-back pour √©viter conflit
        const content = `
            <form id="add-card-form">
                <div class="form-group">
                    <label for="input-card-front">Question</label>
                    <textarea id="input-card-front" required placeholder="Texte de la question"></textarea>
                </div>
                <div class="form-group">
                    <label for="input-card-back">R√©ponse</label>
                    <textarea id="input-card-back" required placeholder="Texte de la r√©ponse"></textarea>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="App.hideModal()">Annuler</button>
                    <button type="submit" class="btn btn-primary">Ajouter</button>
                </div>
            </form>
        `;
        
        this.showModal('Nouvelle carte', content);
        
        setTimeout(() => {
            const form = document.getElementById('add-card-form');
            if (form) {
                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const front = document.getElementById('input-card-front').value.trim();
                    const back = document.getElementById('input-card-back').value.trim();
                    if (front && back) {
                        this.createCard(front, back);
                        this.hideModal();
                    } else {
                        alert('Veuillez remplir les deux champs');
                    }
                });
            }
        }, 10);
    },
    
    showEditCardModal(cardIndex) {
        if (!this.currentDeckId) return;
        const deck = Storage.getDeck(this.currentDeckId);
        if (!deck || !deck.cards[cardIndex]) return;
        
        const card = deck.cards[cardIndex];
        
        // IDs MODIFI√âS: input-edit-card-front et input-edit-card-back
        const content = `
            <form id="edit-card-form">
                <div class="form-group">
                    <label for="input-edit-card-front">Question</label>
                    <textarea id="input-edit-card-front" required>${this.escapeHtml(card.front)}</textarea>
                </div>
                <div class="form-group">
                    <label for="input-edit-card-back">R√©ponse</label>
                    <textarea id="input-edit-card-back" required>${this.escapeHtml(card.back)}</textarea>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="App.hideModal()">Annuler</button>
                    <button type="submit" class="btn btn-primary">Enregistrer</button>
                </div>
            </form>
        `;
        
        this.showModal('Modifier la carte', content);
        
        setTimeout(() => {
            const form = document.getElementById('edit-card-form');
            if (form) {
                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const front = document.getElementById('input-edit-card-front').value.trim();
                    const back = document.getElementById('input-edit-card-back').value.trim();
                    if (front && back) {
                        this.updateCard(cardIndex, front, back);
                        this.hideModal();
                    } else {
                        alert('Veuillez remplir les deux champs');
                    }
                });
            }
        }, 10);
    },
    
    // ============================================
    // GESTION DES DECKS
    // ============================================
    
    createDeck(name) {
        const deck = {
            id: Date.now().toString(),
            name: name,
            cards: [],
            createdAt: Date.now()
        };
        
        Storage.saveDeck(deck);
        this.renderDecks();
    },
    
    updateDeck(name) {
        if (!this.currentDeckId) return;
        const deck = Storage.getDeck(this.currentDeckId);
        if (deck) {
            deck.name = name;
            Storage.saveDeck(deck);
            document.getElementById('deck-title').textContent = name;
            this.renderDecks();
        }
    },
    
    deleteDeck(id) {
        if (confirm('√ätes-vous s√ªr de vouloir supprimer ce deck ?')) {
            Storage.deleteDeck(id);
            if (this.currentDeckId === id) {
                this.showDecksView();
            } else {
                this.renderDecks();
            }
        }
    },
    
    // ============================================
    // GESTION DES CARTES
    // ============================================
    
    createCard(front, back) {
        if (!this.currentDeckId) {
            console.error('Aucun deck s√©lectionn√©');
            return;
        }
        
        const deck = Storage.getDeck(this.currentDeckId);
        if (!deck) {
            console.error('Deck non trouv√©');
            return;
        }
        
        const card = {
            front: front,
            back: back,
            easeFactor: 2.5,
            interval: 1,
            repetitions: 0,
            againCount: 0,
            nextReview: null,
            lastReview: null
        };
        
        deck.cards.push(card);
        Storage.saveDeck(deck);
        this.renderCards();
        this.renderDecks();
    },
    
    editCard(index) {
        this.showEditCardModal(index);
    },
    
    updateCard(index, front, back) {
        if (!this.currentDeckId) return;
        const deck = Storage.getDeck(this.currentDeckId);
        if (deck && deck.cards[index]) {
            deck.cards[index].front = front;
            deck.cards[index].back = back;
            Storage.saveDeck(deck);
            this.renderCards();
        }
    },
    
    deleteCard(index) {
        if (!this.currentDeckId) return;
        if (confirm('√ätes-vous s√ªr de vouloir supprimer cette carte ?')) {
            const deck = Storage.getDeck(this.currentDeckId);
            if (deck && deck.cards[index]) {
                deck.cards.splice(index, 1);
                Storage.saveDeck(deck);
                this.renderCards();
                this.renderDecks(); // Rafra√Æchir l'affichage du compteur
            }
        }
    },
    
    // ============================================
    // R√âVISION
    // ============================================
    
    renderReviewCard() {
        if (this.currentReviewIndex >= this.reviewCards.length) {
            const reviewCard = document.getElementById('review-card');
            const reviewButtons = document.getElementById('review-buttons');
            const reviewProgress = document.getElementById('review-progress');
            
            if (reviewCard) {
                reviewCard.innerHTML = `
                    <div class="card-side">
                        <p>üéâ F√©licitations !<br><br>Vous avez termin√© toutes les cartes √† r√©viser.</p>
                    </div>
                `;
            }
            if (reviewButtons) {
                reviewButtons.classList.add('hidden');
            }
            if (reviewProgress) {
                reviewProgress.textContent = 'Termin√©';
            }
            return;
        }
        
        // Restaurer la structure HTML si elle a √©t√© modifi√©e
        const reviewCard = document.getElementById('review-card');
        if (reviewCard && !reviewCard.querySelector('#card-front')) {
            reviewCard.innerHTML = `
                <div id="card-front" class="card-side">
                    <p id="front-text"></p>
                </div>
                <div id="card-back" class="card-side hidden">
                    <p id="back-text"></p>
                </div>
                <div id="reveal-hint" class="reveal-hint">Tapez pour r√©v√©ler</div>
            `;
        }
        
        const card = this.reviewCards[this.currentReviewIndex];
        const total = this.reviewCards.length;
        const current = this.currentReviewIndex + 1;
        
        const frontText = document.getElementById('front-text');
        const backText = document.getElementById('back-text');
        const cardFront = document.getElementById('card-front');
        const cardBack = document.getElementById('card-back');
        const revealHint = document.getElementById('reveal-hint');
        const reviewButtons = document.getElementById('review-buttons');
        const reviewProgress = document.getElementById('review-progress');
        
        if (frontText) frontText.textContent = card.front;
        if (backText) backText.textContent = card.back;
        if (cardFront) cardFront.classList.remove('hidden');
        if (cardBack) cardBack.classList.add('hidden');
        if (revealHint) revealHint.style.display = 'block';
        if (reviewButtons) reviewButtons.classList.add('hidden');
        if (reviewProgress) reviewProgress.textContent = `${current} / ${total}`;
        
        this.isRevealed = false;
    },
    
    revealAnswer() {
        if (this.isRevealed) return;
        
        const cardFront = document.getElementById('card-front');
        const cardBack = document.getElementById('card-back');
        const revealHint = document.getElementById('reveal-hint');
        const reviewButtons = document.getElementById('review-buttons');
        
        if (!cardFront || !cardBack || !revealHint || !reviewButtons) return;
        
        this.isRevealed = true;
        cardFront.classList.add('hidden');
        cardBack.classList.remove('hidden');
        revealHint.style.display = 'none';
        reviewButtons.classList.remove('hidden');
    },
    
    rateCard(quality) {
        if (this.currentReviewIndex >= this.reviewCards.length) return;
        
        const card = this.reviewCards[this.currentReviewIndex];
        const deck = Storage.getDeck(this.currentDeckId);
        
        if (deck) {
            const deckCard = deck.cards.find(c => c.front === card.front && c.back === card.back);
            if (deckCard) {
                SM2.calculateNextReview(deckCard, quality);
                Storage.saveDeck(deck);
            }
        }
        
        this.currentReviewIndex++;
        this.renderReviewCard();
    },
    
    // ============================================
    // IMPORT / EXPORT
    // ============================================
    
    exportDeck() {
        if (!this.currentDeckId) return;
        const deck = Storage.getDeck(this.currentDeckId);
        if (!deck) return;
        
        const exportData = {
            name: deck.name,
            cards: deck.cards.map(card => ({
                front: card.front,
                back: card.back
            }))
        };
        
        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${deck.name.replace(/[^a-z0-9]/gi, '_')}.json`;
        link.click();
        URL.revokeObjectURL(url);
    },
    
    importDeck(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const importData = JSON.parse(e.target.result);
                
                if (!importData.name || !Array.isArray(importData.cards)) {
                    throw new Error('Format de fichier invalide');
                }
                
                const deck = {
                    id: Date.now().toString(),
                    name: importData.name,
                    cards: importData.cards.map(card => ({
                        front: card.front,
                        back: card.back,
                        easeFactor: 2.5,
                        interval: 1,
                        repetitions: 0,
                        againCount: 0,
                        nextReview: null,
                        lastReview: null
                    })),
                    createdAt: Date.now()
                };
                
                Storage.saveDeck(deck);
                this.renderDecks();
                alert(`Deck "${deck.name}" import√© avec succ√®s !`);
                
            } catch (error) {
                alert('Erreur lors de l\'import : ' + error.message);
            }
        };
        
        reader.readAsText(file);
        event.target.value = '';
    },
    
    // ============================================
    // SERVICE WORKER
    // ============================================
    
    registerServiceWorker() {
        if ('serviceWorker' in navigator) {
            // V√©rifier que nous ne sommes pas en mode file://
            if (window.location.protocol === 'file:') {
                console.log('Service Worker d√©sactiv√© en mode file://');
                return;
            }
            
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(reg => console.log('Service Worker enregistr√©'))
                    .catch(err => {
                        // Ignorer silencieusement l'erreur en mode d√©veloppement
                        if (window.location.protocol !== 'file:') {
                            console.log('Erreur Service Worker:', err);
                        }
                    });
            });
        }
    },
    
    // ============================================
    // UTILITAIRES
    // ============================================
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
};

// Initialiser l'application au chargement
document.addEventListener('DOMContentLoaded', () => {
    App.init();
});

================================================================================
FICHIER 3: style.css
================================================================================

/* Reset et variables */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    --primary-color: #2196F3;
    --primary-dark: #1976D2;
    --primary-light: #64B5F6;
    --background: #FFFFFF;
    --surface: #F5F5F5;
    --text-primary: #212121;
    --text-secondary: #757575;
    --border: #E0E0E0;
    --success: #4CAF50;
    --warning: #FF9800;
    --error: #F44336;
    --shadow: rgba(0, 0, 0, 0.1);
    --shadow-hover: rgba(0, 0, 0, 0.15);
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    background: var(--background);
    color: var(--text-primary);
    line-height: 1.6;
    overflow-x: hidden;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

/* Views */
.view {
    display: none;
    min-height: 100vh;
    padding-bottom: 100px;
}

.view.active {
    display: block;
}

/* Header */
header {
    background: var(--primary-color);
    color: white;
    padding: 15px 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: 0 2px 4px var(--shadow);
    position: sticky;
    top: 0;
    z-index: 100;
}

header h1 {
    font-size: 20px;
    font-weight: 600;
    flex: 1;
    text-align: center;
}

.header-actions {
    display: flex;
    gap: 10px;
}

.icon-btn {
    background: rgba(255, 255, 255, 0.2);
    border: none;
    color: white;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    -webkit-tap-highlight-color: transparent;
}

.icon-btn:active {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(0.95);
}

/* Decks Grid/List */
.decks-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 15px;
    padding: 20px;
}

.decks-grid.list-view {
    grid-template-columns: 1fr;
}

.deck-card {
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 2px 8px var(--shadow);
    cursor: pointer;
    transition: all 0.2s ease;
    border: 2px solid transparent;
    position: relative;
    overflow: hidden;
}

.deck-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: var(--primary-color);
}

.deck-card:active {
    transform: scale(0.98);
    box-shadow: 0 1px 4px var(--shadow);
}

.deck-card:hover {
    box-shadow: 0 4px 12px var(--shadow-hover);
}

.deck-card h3 {
    font-size: 18px;
    margin-bottom: 8px;
    color: var(--text-primary);
}

.deck-card .deck-info {
    font-size: 14px;
    color: var(--text-secondary);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.deck-card .deck-actions {
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    gap: 5px;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.deck-card:hover .deck-actions {
    opacity: 1;
}

.deck-action-btn {
    background: rgba(0, 0, 0, 0.1);
    border: none;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.deck-action-btn:active {
    transform: scale(0.9);
}

/* Cards List */
.cards-list {
    padding: 20px;
}

.card-item {
    background: white;
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 15px;
    box-shadow: 0 2px 8px var(--shadow);
    cursor: pointer;
    transition: all 0.2s ease;
    border-left: 4px solid var(--primary-color);
}

.card-item:active {
    transform: translateX(5px);
}

.card-item-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 10px;
}

.card-item-content {
    font-size: 14px;
    color: var(--text-secondary);
    margin-bottom: 8px;
}

.card-item-content strong {
    color: var(--text-primary);
}

.card-item-actions {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}

.card-action-btn {
    background: var(--surface);
    border: none;
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 12px;
    cursor: pointer;
    color: var(--text-primary);
    transition: all 0.2s ease;
}

.card-action-btn:active {
    transform: scale(0.95);
}

/* FAB (Floating Action Button) */
.fab-container {
    position: fixed;
    bottom: 30px;
    right: 30px;
    z-index: 1000;
}

.fab {
    width: 56px;
    height: 56px;
    border-radius: 50%;
    background: var(--primary-color);
    color: white;
    border: none;
    font-size: 32px;
    cursor: pointer;
    box-shadow: 0 4px 12px var(--shadow-hover);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    -webkit-tap-highlight-color: transparent;
}

.fab:active {
    transform: scale(0.9);
    box-shadow: 0 2px 6px var(--shadow);
}

/* Review Card */
.review-card {
    margin: 30px 20px;
    min-height: 300px;
    perspective: 1000px;
}

.card-side {
    background: white;
    border-radius: 16px;
    padding: 40px 30px;
    box-shadow: 0 4px 16px var(--shadow);
    min-height: 300px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    position: relative;
    cursor: pointer;
    transition: transform 0.3s ease;
    -webkit-tap-highlight-color: transparent;
}

.card-side p {
    font-size: 24px;
    line-height: 1.6;
    color: var(--text-primary);
    word-wrap: break-word;
}

.card-side.hidden {
    display: none;
}

.reveal-hint {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 14px;
    color: var(--text-secondary);
    opacity: 0.7;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 0.7; }
    50% { opacity: 1; }
}

.review-buttons {
    display: flex;
    gap: 15px;
    padding: 20px;
    justify-content: center;
    flex-wrap: wrap;
}

.review-buttons.hidden {
    display: none;
}

.review-btn {
    flex: 1;
    min-width: 100px;
    max-width: 150px;
    padding: 16px 24px;
    border: none;
    border-radius: 25px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    color: white;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px var(--shadow);
    -webkit-tap-highlight-color: transparent;
}

.review-btn:active {
    transform: scale(0.95);
}

.review-btn.again {
    background: var(--error);
}

.review-btn.good {
    background: var(--primary-color);
}

.review-btn.easy {
    background: var(--success);
}

#review-progress {
    font-size: 14px;
    opacity: 0.9;
}

/* Modal */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    padding: 20px;
    animation: fadeIn 0.2s ease;
}

.modal-overlay.hidden {
    display: none;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.modal {
    background: white;
    border-radius: 16px;
    width: 100%;
    max-width: 400px;
    max-height: 80vh;
    overflow: hidden;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    animation: slideUp 0.3s ease;
}

@keyframes slideUp {
    from {
        transform: translateY(20px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.modal-header {
    padding: 20px;
    border-bottom: 1px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.modal-header h2 {
    font-size: 20px;
    color: var(--text-primary);
}

.modal-close {
    background: none;
    border: none;
    font-size: 28px;
    color: var(--text-secondary);
    cursor: pointer;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s ease;
}

.modal-close:active {
    background: var(--surface);
    transform: scale(0.9);
}

.modal-body {
    padding: 20px;
    max-height: 60vh;
    overflow-y: auto;
}

.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    margin-bottom: 8px;
    font-size: 14px;
    color: var(--text-secondary);
    font-weight: 500;
}

.form-group input,
.form-group textarea {
    width: 100%;
    padding: 12px;
    border: 2px solid var(--border);
    border-radius: 8px;
    font-size: 16px;
    font-family: inherit;
    transition: border-color 0.2s ease;
}

.form-group input:focus,
.form-group textarea:focus {
    outline: none;
    border-color: var(--primary-color);
}

.form-group textarea {
    resize: vertical;
    min-height: 100px;
}

.form-actions {
    display: flex;
    gap: 10px;
    margin-top: 20px;
}

.btn {
    flex: 1;
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.btn-primary {
    background: var(--primary-color);
    color: white;
}

.btn-primary:active {
    background: var(--primary-dark);
    transform: scale(0.98);
}

.btn-secondary {
    background: var(--surface);
    color: var(--text-primary);
}

.btn-secondary:active {
    background: var(--border);
    transform: scale(0.98);
}

.btn-danger {
    background: var(--error);
    color: white;
}

.btn-danger:active {
    background: #D32F2F;
    transform: scale(0.98);
}

/* Empty state */
.empty-state {
    text-align: center;
    padding: 60px 20px;
    color: var(--text-secondary);
}

.empty-state-icon {
    font-size: 64px;
    margin-bottom: 20px;
    opacity: 0.5;
}

.empty-state-text {
    font-size: 16px;
}

/* Responsive */
@media (max-width: 480px) {
    .decks-grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 12px;
        padding: 15px;
    }
    
    .card-side p {
        font-size: 20px;
    }
    
    .review-buttons {
        flex-direction: column;
    }
    
    .review-btn {
        max-width: 100%;
    }
}

/* Animations */
@keyframes slideIn {
    from {
        transform: translateX(100%);
    }
    to {
        transform: translateX(0);
    }
}

.view.active {
    animation: slideIn 0.3s ease;
}

/* Scrollbar */
::-webkit-scrollbar {
    width: 8px;
}

::-webkit-scrollbar-track {
    background: var(--surface);
}

::-webkit-scrollbar-thumb {
    background: var(--border);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--text-secondary);
}

================================================================================
FICHIER 4: manifest.json
================================================================================

{
  "name": "FlashCards - AnkiApp Style",
  "short_name": "FlashCards",
  "description": "Application de flashcards avec r√©p√©tition espac√©e",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#FFFFFF",
  "theme_color": "#2196F3",
  "orientation": "portrait",
  "icons": [
    {
      "src": "icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ],
  "categories": ["education", "productivity"],
  "screenshots": [],
  "shortcuts": []
}

================================================================================
FICHIER 5: service-worker.js
================================================================================

// Service Worker pour cache offline
const CACHE_NAME = 'flashcards-v1';
const urlsToCache = [
  './',
  './index.html',
  './style.css',
  './script.js',
  './manifest.json',
  './icon-192.png',
  './icon-512.png'
];

// Installation du Service Worker
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('Cache ouvert');
        return cache.addAll(urlsToCache);
      })
      .catch((err) => {
        console.log('Erreur lors du cache:', err);
      })
  );
  self.skipWaiting();
});

// Activation du Service Worker
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            console.log('Suppression de l\'ancien cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
  return self.clients.claim();
});

// Interception des requ√™tes
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        // Retourner la r√©ponse du cache si disponible, sinon faire une requ√™te r√©seau
        if (response) {
          return response;
        }
        return fetch(event.request).then((response) => {
          // V√©rifier si la r√©ponse est valide
          if (!response || response.status !== 200 || response.type !== 'basic') {
            return response;
          }
          
          // Cloner la r√©ponse pour le cache
          const responseToCache = response.clone();
          
          caches.open(CACHE_NAME).then((cache) => {
            cache.put(event.request, responseToCache);
          });
          
          return response;
        });
      })
      .catch(() => {
        // En cas d'erreur, retourner une page offline si c'est une navigation
        if (event.request.mode === 'navigate') {
          return caches.match('./index.html');
        }
      })
  );
});

================================================================================
FICHIER 6: exemple-deck.json
================================================================================

{
  "name": "Vocabulaire Anglais - Exemple",
  "cards": [
    {
      "front": "Bonjour",
      "back": "Hello"
    },
    {
      "front": "Au revoir",
      "back": "Goodbye"
    },
    {
      "front": "Merci",
      "back": "Thank you"
    },
    {
      "front": "S'il vous pla√Æt",
      "back": "Please"
    },
    {
      "front": "Excusez-moi",
      "back": "Excuse me"
    }
  ]
}

================================================================================
FICHIER 7: generate-icons.html
================================================================================

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©n√©rateur d'ic√¥nes PWA</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 50px auto;
            padding: 20px;
            text-align: center;
        }
        canvas {
            border: 1px solid #ccc;
            margin: 10px;
        }
        button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
        }
        button:hover {
            background: #1976D2;
        }
    </style>
</head>
<body>
    <h1>G√©n√©rateur d'ic√¥nes PWA</h1>
    <p>Ouvrez cette page dans un navigateur et cliquez sur "T√©l√©charger les ic√¥nes"</p>
    
    <canvas id="icon192" width="192" height="192"></canvas>
    <canvas id="icon512" width="512" height="512"></canvas>
    
    <br>
    <button onclick="downloadIcons()">T√©l√©charger les ic√¥nes</button>
    
    <script>
        function drawIcon(canvas, size) {
            const ctx = canvas.getContext('2d');
            const radius = size * 0.15;
            
            // Fond bleu avec coins arrondis
            ctx.beginPath();
            ctx.moveTo(radius, 0);
            ctx.lineTo(size - radius, 0);
            ctx.quadraticCurveTo(size, 0, size, radius);
            ctx.lineTo(size, size - radius);
            ctx.quadraticCurveTo(size, size, size - radius, size);
            ctx.lineTo(radius, size);
            ctx.quadraticCurveTo(0, size, 0, size - radius);
            ctx.lineTo(0, radius);
            ctx.quadraticCurveTo(0, 0, radius, 0);
            ctx.closePath();
            ctx.fillStyle = '#2196F3';
            ctx.fill();
            
            // Symbole de carte
            ctx.fillStyle = 'white';
            ctx.font = `bold ${size * 0.3}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üÉè', size / 2, size / 2);
        }
        
        function downloadCanvas(canvas, filename) {
            canvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }, 'image/png');
        }
        
        function downloadIcons() {
            const canvas192 = document.getElementById('icon192');
            const canvas512 = document.getElementById('icon512');
            
            drawIcon(canvas192, 192);
            drawIcon(canvas512, 512);
            
            downloadCanvas(canvas192, 'icon-192.png');
            setTimeout(() => {
                downloadCanvas(canvas512, 'icon-512.png');
            }, 500);
            
            alert('Ic√¥nes t√©l√©charg√©es ! Placez-les dans le dossier racine du projet.');
        }
        
        // Dessiner les aper√ßus
        window.onload = function() {
            drawIcon(document.getElementById('icon192'), 192);
            drawIcon(document.getElementById('icon512'), 512);
        };
    </script>
</body>
</html>

================================================================================
FICHIER 8: README.md
================================================================================

# FlashCards - Application PWA de R√©vision

Application web compl√®te de flashcards avec r√©p√©tition espac√©e, inspir√©e d'AnkiApp. Fonctionne comme PWA sur iPhone et autres appareils.

## üìÅ Structure des fichiers

```
.
‚îú‚îÄ‚îÄ index.html          # Structure HTML principale
‚îú‚îÄ‚îÄ style.css           # Styles (th√®me blanc/bleu AnkiApp)
‚îú‚îÄ‚îÄ script.js           # Logique de l'application
‚îú‚îÄ‚îÄ manifest.json       # Configuration PWA
‚îú‚îÄ‚îÄ service-worker.js   # Service Worker pour cache offline
‚îú‚îÄ‚îÄ icon-192.png       # Ic√¥ne 192x192 (√† cr√©er)
‚îú‚îÄ‚îÄ icon-512.png       # Ic√¥ne 512x512 (√† cr√©er)
‚îî‚îÄ‚îÄ README.md          # Ce fichier
```

## üöÄ H√©bergement

### Option 1 : GitHub Pages

1. **Cr√©er un d√©p√¥t GitHub**
   ```bash
   git init
   git add .
   git commit -m "Initial commit"
   git remote add origin https://github.com/votre-username/flashcards.git
   git push -u origin main
   ```

2. **Activer GitHub Pages**
   - Allez dans Settings > Pages
   - S√©lectionnez la branche `main` et le dossier `/ (root)`
   - L'application sera disponible √† `https://votre-username.github.io/flashcards/`

### Option 2 : Netlify

1. **Via l'interface web**
   - Allez sur [netlify.com](https://netlify.com)
   - Glissez-d√©posez le dossier du projet
   - L'application sera d√©ploy√©e automatiquement

2. **Via Netlify CLI**
   ```bash
   npm install -g netlify-cli
   netlify deploy --prod
   ```

### Option 3 : Vercel

1. **Via l'interface web**
   - Allez sur [vercel.com](https://vercel.com)
   - Importez votre d√©p√¥t GitHub
   - Vercel d√©tectera automatiquement le projet

2. **Via Vercel CLI**
   ```bash
   npm install -g vercel
   vercel --prod
   ```

### Option 4 : Serveur local (d√©veloppement)

```bash
# Avec Python 3
python -m http.server 8000

# Avec Node.js (http-server)
npx http-server -p 8000

# Avec PHP
php -S localhost:8000
```

Puis ouvrez `http://localhost:8000` dans votre navigateur.

## üì± Installation sur iPhone (PWA)

1. **Ouvrir l'application dans Safari**
   - Allez sur l'URL de votre application h√©berg√©e
   - Assurez-vous d'utiliser Safari (pas Chrome ou Firefox)

2. **Ajouter √† l'√©cran d'accueil**
   - Appuyez sur le bouton de partage (carr√© avec fl√®che vers le haut)
   - Faites d√©filer et s√©lectionnez **"Sur l'√©cran d'accueil"** ou **"Ajouter √† l'√©cran d'accueil"**
   - Personnalisez le nom si vous le souhaitez
   - Appuyez sur **"Ajouter"**

3. **Lancer l'application**
   - L'ic√¥ne appara√Ætra sur votre √©cran d'accueil
   - L'application s'ouvrira en mode standalone (sans barre d'adresse Safari)

## üé® Cr√©ation des ic√¥nes

Pour que la PWA fonctionne correctement, vous devez cr√©er deux fichiers d'ic√¥nes :

- `icon-192.png` (192x192 pixels)
- `icon-512.png` (512x512 pixels)

### M√©thode 1 : Outil en ligne
1. Cr√©ez une ic√¥ne carr√©e (fond bleu #2196F3 avec un symbole de carte üÉè)
2. Utilisez un outil comme [PWA Asset Generator](https://github.com/onderceylan/pwa-asset-generator) ou [RealFaviconGenerator](https://realfavicongenerator.net/)
3. T√©l√©chargez les ic√¥nes et placez-les dans le dossier racine

### M√©thode 2 : Outil de design
- Utilisez Figma, Canva, ou Photoshop
- Cr√©ez une ic√¥ne 512x512 avec fond bleu #2196F3
- Exportez en PNG aux tailles 192x192 et 512x512

### M√©thode 3 : Script simple (Node.js)
Cr√©ez un fichier `generate-icons.js` :
```javascript
const fs = require('fs');
const { createCanvas } = require('canvas');

function createIcon(size) {
  const canvas = createCanvas(size, size);
  const ctx = canvas.getContext('2d');
  
  // Fond bleu
  ctx.fillStyle = '#2196F3';
  ctx.fillRect(0, 0, size, size);
  
  // Symbole de carte (texte simple)
  ctx.fillStyle = 'white';
  ctx.font = `bold ${size * 0.4}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('üÉè', size / 2, size / 2);
  
  return canvas.toBuffer('image/png');
}

fs.writeFileSync('icon-192.png', createIcon(192));
fs.writeFileSync('icon-512.png', createIcon(512));
console.log('Ic√¥nes cr√©√©es !');
```

Puis ex√©cutez : `node generate-icons.js`

## üì¶ Import / Export JSON

### Format JSON

L'application utilise un format JSON simple pour l'import/export des decks :

```json
{
  "name": "Nom du deck",
  "cards": [
    {
      "front": "Question",
      "back": "R√©ponse"
    },
    {
      "front": "Autre question",
      "back": "Autre r√©ponse"
    }
  ]
}
```

### Export d'un deck

1. Ouvrez le deck que vous souhaitez exporter
2. Cliquez sur le bouton **‚¨Ü** (Exporter) dans l'en-t√™te
3. Le fichier JSON sera t√©l√©charg√© automatiquement
4. Le nom du fichier sera bas√© sur le nom du deck (ex: `Vocabulaire_anglais.json`)

### Import d'un deck

1. Cliquez sur le bouton **‚¨á** (Importer) dans l'en-t√™te d'un deck ou cr√©ez un nouveau deck
2. S√©lectionnez un fichier JSON au format d√©crit ci-dessus
3. Le deck sera cr√©√© avec toutes les cartes import√©es
4. Les m√©tadonn√©es de r√©vision (SM-2) seront r√©initialis√©es pour les nouvelles cartes

### Exemple de fichier JSON

```json
{
  "name": "Vocabulaire Anglais",
  "cards": [
    {
      "front": "Bonjour",
      "back": "Hello"
    },
    {
      "front": "Au revoir",
      "back": "Goodbye"
    },
    {
      "front": "Merci",
      "back": "Thank you"
    }
  ]
}
```

## üîÑ Syst√®me de r√©p√©tition espac√©e (SM-2)

L'application utilise un algorithme SM-2 simplifi√© :

- **Encore** : R√©initialise la carte (r√©vision dans 1 jour)
- **Bien** : Augmente l'intervalle selon l'ease factor
- **Facile** : Augmente l'intervalle plus rapidement

Les cartes √† r√©viser sont celles dont la date de prochaine r√©vision est pass√©e ou n'a jamais √©t√© d√©finie.

## üíæ Stockage des donn√©es

Toutes les donn√©es sont stock√©es dans le **LocalStorage** du navigateur :
- Les decks et leurs cartes
- Les m√©tadonn√©es de r√©vision (ease factor, intervalle, dates)
- Persistance m√™me apr√®s fermeture du navigateur

**Note** : Les donn√©es sont stock√©es localement sur l'appareil. Pour sauvegarder vos decks, utilisez la fonction d'export.

## üõ†Ô∏è Fonctionnalit√©s

### Decks
- ‚úÖ Cr√©er, renommer, supprimer des decks
- ‚úÖ Affichage en grille ou liste
- ‚úÖ Compteur de cartes √† r√©viser

### Cartes
- ‚úÖ Ajouter, modifier, supprimer des cartes
- ‚úÖ Texte uniquement (question/r√©ponse)
- ‚úÖ Affichage de la prochaine date de r√©vision

### R√©vision
- ‚úÖ Mode r√©vision avec tap pour r√©v√©ler
- ‚úÖ Boutons "Encore", "Bien", "Facile"
- ‚úÖ Algorithme SM-2 simplifi√©
- ‚úÖ Compteur de progression

### PWA
- ‚úÖ Fonctionne hors ligne
- ‚úÖ Installable sur iPhone
- ‚úÖ Cache des ressources
- ‚úÖ Interface native

## üêõ D√©pannage

### L'application ne s'installe pas sur iPhone
- V√©rifiez que vous utilisez Safari (pas Chrome)
- Assurez-vous que l'application est servie en HTTPS (obligatoire pour PWA)
- V√©rifiez que `manifest.json` est accessible

### Le Service Worker ne fonctionne pas
- V√©rifiez la console du navigateur pour les erreurs
- Assurez-vous que l'application est servie depuis un serveur (pas `file://`)
- Videz le cache du navigateur et rechargez

### Les donn√©es ne persistent pas
- V√©rifiez que LocalStorage est activ√© dans votre navigateur
- Ne naviguez pas en mode priv√© (LocalStorage peut √™tre d√©sactiv√©)

## üìù Notes techniques

- **Framework** : Vanilla JavaScript (pas de d√©pendances)
- **Stockage** : LocalStorage
- **Algorithme** : SM-2 simplifi√©
- **Compatibilit√©** : Navigateurs modernes (Chrome, Safari, Firefox, Edge)
- **Responsive** : Optimis√© pour mobile et desktop

## üìÑ Licence

Libre d'utilisation pour usage personnel et commercial.

---

**Bon apprentissage ! üéì**

================================================================================
FIN DU R√âSUM√â
================================================================================

Ce fichier contient l'int√©gralit√© du code source de l'application FlashCards.
Tous les fichiers principaux sont inclus avec leurs s√©parateurs pour faciliter
la lecture et la compr√©hension de la structure du projet.

Pour utiliser ce code :
1. Cr√©ez les fichiers correspondants dans votre projet
2. Copiez le contenu de chaque section dans le fichier appropri√©
3. Assurez-vous d'avoir les ic√¥nes icon-192.png et icon-512.png
4. D√©ployez sur un serveur web (HTTPS requis pour PWA)

